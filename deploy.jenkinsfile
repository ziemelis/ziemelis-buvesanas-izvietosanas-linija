pipeline{
    agent any
environment {
        key = credentials('EC2')
        REPO = credentials('my-ecr-repo')
        FE_TAG = "${params.feBuild}"
        FE_PORT = "3000"
        FE_IMAGE = "nextjs-app-new"
        ip_address = "0.0.0.0"
    }
    stages {
        stage('Write Docker Compose file') {
            steps {
                script{
                def dockerCompose = """
                    version: "3"
                    services:
                      frontend:
                        image: ${REPO}/${FE_IMAGE}:${FE_TAG}
                        ports:
                          - ${FE_PORT}:${FE_PORT}
                """

                writeFile file: 'docker-compose.yaml', text: dockerCompose
                }
            }
        }
    stage('Innit Terraform') {
            steps {
             sh 'terraform init'
            }
        }
        stage('Run terraform apply') {
            steps {
             sh 'terraform apply -auto-approve -var "pem_file=${key}" -var "pullfe_command=docker pull ${REPO}/${FE_IMAGE}:${FE_TAG}" -var "deploy_command=docker compose up -d " -var "ec2_name=Deploy Nr #$BUILD_NUMBER"'
             script{
                ip_address = readFile '../ip_file'
                }
             }
        }
    }        
    post {
    failure {
      slackSend (color: '#FF0000', message: "Deploy pipeline build #$BUILD_NUMBER failed.\n Build: $BUILD_URL")
    }
    success {
        slackSend(color: '#00FF00', message: "Deploy pipeline build #$BUILD_NUMBER finished.\n Ip address: http://${ip_address}:${FE_PORT}/")
    }
    always {
      cleanWs()
    }
  }
}  